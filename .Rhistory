# shows range of unmanaged scenario
# stat_summary(fun = min, geom = 'line', size=0.4, alpha=0.6, linetype=2, color="grey20") +
# stat_summary(fun = max, geom = 'line', size=0.4, alpha=0.6, linetype=2, color="grey20") +
geom_ribbon(aes(ymin=mgmt_growth.lwr, ymax = mgmt_growth.upr,
group=reorder(cap_name, rev(cap_name))),
fill='#18BFC2', alpha=0.04) +
stat_summary(aes(y=mgmt_growth.lwr), fun = min, geom = 'line', size=0.3, alpha=0.9, linetype=1, color="grey10") +
stat_summary(aes(y=mgmt_growth.upr),fun = max, geom = 'line', size=0.3, alpha=0.9, linetype=1, color="grey10") +
# geom_ribbon(aes(ymin=pred.lwr, ymax = pred.upr, group=reorder(cap_name, rev(cap_name)), fill=cap_name), colour=NA) +
stat_summary(aes(y=pred.lwr), fun = min, geom = 'line', size=0.3, alpha=0.9, linetype=2, color="grey10") +
stat_summary(aes(y=pred.upr),fun = max, geom = 'line', size=0.3, alpha=0.9, linetype=2, color="grey10") +
### This gives just the lines
# geom_line(aes(y=mgmt_growth, group=reorder(cap_name, rev(cap_name)), color=cap_name), lwd=0.5, alpha=0.5)+
# scale_colour_viridis_c(option='turbo') +
scale_colour_continuous_sequential("Batlow", rev=F) +
guides(colour = guide_colourbar(barwidth = 8, barheight = 0.5, title="Territory Capacity", title.vjust=1)) +
facet_grid(mgmt_removed ~ mgmt_year ) +
# define plot style n stuff
coord_cartesian(ylim=c(8,upper_capacity +5), xlim = c(2007, 2060))+
labs(x = 'Year', y="Number of Territories")+
theme_bw() +
theme(legend.position = "bottom",
axis.title.y = element_text(margin = margin(t = 0, r = 3, b = 0, l = 0)),
axis.title.x = element_text(margin = margin(t = 3, r = 0, b = 0, l = 0)))
}
mgmt_p <- mgmt_plot(mgmt_df)
add_general_facet_labs(mgmt_p, 'n territories removed each year', ' Year managment starts') %>%
ggsave(file.path(plot_dir, 'MgmtDynamics.png'), .,
dpi=600, height=180, width=180, units='mm')
mgmt_df_big <- hacked_df %>%
group_by(cap_name) %>%
group_split() %>%
purrr::map(., ~ mgmt_scenario(., c(2022:2040), c(1:15))) %>%
bind_rows()
mgmt_p_matrix <- mgmt_plot(mgmt_df_big)
add_general_facet_labs(mgmt_p_matrix, 'n territories removed each year', ' Year managment starts') %>%
ggsave(file.path(plot_dir, 'MgmtDynamicsMatrix.png'), .,
dpi=300)
add_general_facet_labs(mgmt_p_matrix, 'n territories removed each year', ' Year managment starts') %>%
ggsave(file.path(plot_dir, 'MgmtDynamicsMatrix.png'), .,
dpi=300, height=675, width=1080, units='mm')
bind_cols(
get_summ(hacked_df, max, min, .fitted, 'early_mean'),
get_summ(hacked_df, min, max, .fitted, 'late_mean'),
get_summ(hacked_df, max, min, pred.upr, 'lower_CI'),
get_summ(hacked_df, min, max, pred.lwr, 'upper_CI')
)
180/15*180
add_general_facet_labs(mgmt_p, 'n territories removed each year', ' Year managment starts')
180/4
45*12
c(1,12)
c(1:12)
length(c(2022:2035))
180/3
60*14
add_general_facet_labs(mgmt_p_matrix, 'n territories removed each year', ' Year managment starts') %>%
ggsave(file.path(plot_dir, 'MgmtDynamicsMatrix.png'), .,
dpi=300, height=540*0.8, width=840*0.8, units='mm')
mgmt_df_big <- hacked_df %>%
group_by(cap_name) %>%
group_split() %>%
purrr::map(., ~ mgmt_scenario(., c(2022:2035), c(1:12))) %>%
bind_rows()
mgmt_p_matrix <- mgmt_plot(mgmt_df_big)
add_general_facet_labs(mgmt_p_matrix, 'n territories removed each year', ' Year managment starts') %>%
ggsave(file.path(plot_dir, 'MgmtDynamicsMatrix.png'), .,
dpi=300, height=540*0.8, width=840*0.8, units='mm')
s <- 0.4
s <- 0.4
mgmt_p_matrix2 <- add_general_facet_labs(mgmt_p_matrix, 'n territories removed each year', ' Year managment starts')
s <- 0.4
ggsave(file.path(plot_dir, 'MgmtDynamicsMatrix.png'), mgmt_p_matrix2,
dpi=300, height=540*s, width=840*s, units='mm')
class(mgmt_p_matrix2)
class(mgmt_p_matrix)
mgmt_p_matrix <- mgmt_plot(mgmt_df_big) +
scale_x_continuous(breaks = scales::pretty_breaks(n = 2)) +
scale_y_continuous(breaks = scales::pretty_breaks(n = 3))
mgmt_p_matrix2 <- add_general_facet_labs(mgmt_p_matrix, 'n territories removed each year', ' Year managment starts')
s <- 0.4
ggsave(file.path(plot_dir, 'MgmtDynamicsMatrix.png'), mgmt_p_matrix2,
dpi=300, height=540*s, width=840*s, units='mm')
mgmt_p_matrix <- mgmt_plot(mgmt_df_big) +
scale_x_continuous(breaks = scales::pretty_breaks(n = 3)) +
scale_y_continuous(breaks = scales::pretty_breaks(n = 3))
mgmt_p_matrix2 <- add_general_facet_labs(mgmt_p_matrix, 'n territories removed each year', ' Year managment starts')
s <- 0.4
ggsave(file.path(plot_dir, 'MgmtDynamicsMatrix.png'), mgmt_p_matrix2,
dpi=300, height=540*s, width=840*s, units='mm')
#
c(0:12)
seq(2022, 2026, by=2)
seq(2022, 2036, by=2)
840/14
60*8
seq(1, 13, by=2)
540/12
45*7
mgmt_df_big <- hacked_df %>%
group_by(cap_name) %>%
group_split() %>%
purrr::map(., ~ mgmt_scenario(., seq(2022, 2036, by=2),
seq(1, 13, by=2))) %>%
bind_rows()
mgmt_p_matrix <- mgmt_plot(mgmt_df_big) +
scale_x_continuous(breaks = scales::pretty_breaks(n = 3)) +
scale_y_continuous(breaks = scales::pretty_breaks(n = 3))
mgmt_p_matrix2 <- add_general_facet_labs(mgmt_p_matrix, 'n territories removed each year', ' Year managment starts')
s <- 0.4
ggsave(file.path(plot_dir, 'MgmtDynamicsMatrix.png'), mgmt_p_matrix2,
dpi=300, height=315*s, width=480*s, units='mm')
ggsave(file.path(plot_dir, 'MgmtDynamicsMatrix.png'), mgmt_p_matrix2,
dpi=600, height=315*s, width=480*s, units='mm')
s <- 0.8
ggsave(file.path(plot_dir, 'MgmtDynamicsMatrix.png'), mgmt_p_matrix2,
dpi=600, height=315*s, width=480*s, units='mm')
s <- 0.6
ggsave(file.path(plot_dir, 'MgmtDynamicsMatrix.png'), mgmt_p_matrix2,
dpi=600, height=315*s, width=480*s, units='mm')
seq(0, 13, by=2))
seq(0, 13, by=2)
mgmt_df_big <- hacked_df %>%
group_by(cap_name) %>%
group_split() %>%
purrr::map(., ~ mgmt_scenario(., seq(2022, 2036, by=2),
seq(0, 13, by=2))) %>%
bind_rows()
mgmt_p_matrix <- mgmt_plot(mgmt_df_big) +
scale_x_continuous(breaks = scales::pretty_breaks(n = 3)) +
scale_y_continuous(breaks = scales::pretty_breaks(n = 3))
mgmt_p_matrix2 <- add_general_facet_labs(mgmt_p_matrix, 'n territories removed each year', ' Year managment starts')
s <- 0.6
ggsave(file.path(plot_dir, 'MgmtDynamicsMatrix.png'), mgmt_p_matrix2,
dpi=600, height=315*s, width=480*s, units='mm')
#
# sum stats for paper:
mgmt_df %>%
# filter(mgmt_year %in% c(2022, 2025, 2035)) %>%
filter(mgmt_removed == 5 | mgmt_removed == 7) %>%
filter(cap_name == 120 |cap_name == 183) %>%
group_by(mgmt_year, mgmt_removed, cap_name) %>%
summarise(mgmt_cap = last(mgmt_growth), max_cap = last(.fitted)) %>%
mutate(perc_decline = (max_cap-mgmt_cap)/max_cap*100)
mgmt_df <- hacked_df %>%
group_by(cap_name) %>%
group_split() %>%
purrr::map(., ~ mgmt_scenario(., c(2022, 2026, 2030), c(3, 5, 10, 12))) %>%
bind_rows()
# sum stats for paper:
mgmt_df %>%
# filter(mgmt_year %in% c(2022, 2025, 2035)) %>%
filter(mgmt_removed == 5 | mgmt_removed == 7) %>%
filter(cap_name == 120 |cap_name == 183) %>%
group_by(mgmt_year, mgmt_removed, cap_name) %>%
summarise(mgmt_cap = last(mgmt_growth), max_cap = last(.fitted)) %>%
mutate(perc_decline = (max_cap-mgmt_cap)/max_cap*100)
(120-106)/120*100###???
# create plot.
mgmt_plot <- function(df){
df %>%
# filter(cap_name==115)%>%
ggplot(., aes(x=year_adj, y=.fitted))+
# shows range of unmanaged scenario
# stat_summary(fun = min, geom = 'line', size=0.4, alpha=0.6, linetype=2, color="grey20") +
# stat_summary(fun = max, geom = 'line', size=0.4, alpha=0.6, linetype=2, color="grey20") +
geom_ribbon(aes(ymin=mgmt_growth.lwr, ymax = mgmt_growth.upr,
group=reorder(cap_name, rev(cap_name))),
fill='#18BFC2', alpha=0.04) +
stat_summary(aes(y=mgmt_growth.lwr), fun = min, geom = 'line', size=0.3, alpha=0.9, linetype=1, color="grey10") +
stat_summary(aes(y=mgmt_growth.upr),fun = max, geom = 'line', size=0.3, alpha=0.9, linetype=1, color="grey10") +
# geom_ribbon(aes(ymin=pred.lwr, ymax = pred.upr, group=reorder(cap_name, rev(cap_name)), fill=cap_name), colour=NA) +
stat_summary(aes(y=pred.lwr), fun = min, geom = 'line', size=0.3, alpha=0.9, linetype=2, color="grey10") +
stat_summary(aes(y=pred.upr),fun = max, geom = 'line', size=0.3, alpha=0.9, linetype=2, color="grey10") +
### This gives just the lines
# geom_line(aes(y=mgmt_growth, group=reorder(cap_name, rev(cap_name)), color=cap_name), lwd=0.5, alpha=0.5)+
# scale_colour_viridis_c(option='turbo') +
scale_colour_continuous_sequential("Batlow", rev=F) +
guides(colour = guide_colourbar(barwidth = 8, barheight = 0.5, title="Territory Capacity", title.vjust=1)) +
facet_grid(mgmt_removed ~ mgmt_year ) +
# define plot style n stuff
coord_cartesian(ylim=c(8,upper_capacity +5), xlim = c(2007, 2060))+
labs(x = 'Year', y="Number of Territories")+
theme_bw() +
theme(legend.position = "bottom",
axis.title.y = element_text(margin = margin(t = 0, r = 3, b = 0, l = 0)),
axis.title.x = element_text(margin = margin(t = 3, r = 0, b = 0, l = 0)))
}
mgmt_p <- mgmt_plot(mgmt_df)
add_general_facet_labs(mgmt_p, 'n territories removed each year', ' Year managment starts') %>%
ggsave(file.path(plot_dir, 'MgmtDynamics.png'), .,
dpi=600, height=180, width=180, units='mm')
citation('investr')
?plotFit
?v
?predFit
library(patchwork)
library(sf)
library(magrittr)
library(tidyverse)
library(patchwork)
library(ggfortify)
library(investr)
library(colorspace)
library(grid)
library(gtable)
# devtools::load_all()
library(beavertools)
plot_dir <- file.path(here::here(),"R_Otter_workflow/3_Pop_expansion_predictions/plots")
sim_dir <- file.path(here::here(),"R_Otter_workflow/2_Territory_simulations/exports")
# ---- Read in Data Territroy count data --------------
reclass_terr_list <- readRDS(file='R_Otter_workflow/1_Feed_Sign_Mapping/exports/reclass_terr_list2.Rds')
# get unique names for survey years...
plot_names <- unique(RivOtter_FeedSigns$SurveySeason)
# What is the capacity of the catchment? WILL NEED UPDATING WITH RANGES ETC WHEN SIMULATIONS ARE DONE.
cap_limits <- read_rds(file.path(sim_dir, 'sim_terr.Rds')) %>%
sf::st_drop_geometry() %>%
summarise(lowest = min(n),
highest = max(n))
lower_capacity <- cap_limits$lowest
upper_capacity <- cap_limits$highest
#  ------- set up dataframe for observed territory counts... -------
date_list <- lubridate::dmy(c("30-12-2014", "30-12-2015", "30-12-2016",
"30-12-2017", "30-12-2018", "30-12-2019",
"30-12-2020"))
years_since_release <- c(8:14)
get_terr_counts <- function(terr_map, .season, .year, .ysr){
terr_map %>%
dplyr::filter(user_class == 'Territory') %>%
summarise(terr_count = n(), season= .season, year = .year, years_since = .ysr)
}
count_obj_list <- list(reclass_terr_list, plot_names, date_list, years_since_release)
terr_counts <-  purrr::pmap(count_obj_list, ~get_terr_counts(..1, ..2, ..3, ..4)) %>%
bind_rows() %>%
mutate(year_adj = years_since + 2007) %>%
mutate(terr_count = ifelse(season %in% c('2018 - 2019', '2019 - 2020'), terr_count+1,
ifelse(season %in% c('2020 - 2021'),terr_count + 2, terr_count))) %>% # required because some territories not correctly identified due to semi-automate process.
mutate(name = 'Observed Data')
# reclass_terr_list[[1]] %>% # for double checking only.
#   filter(user_class == "Territory") %>%
#   ggplot(., aes(fill=(as.character(id)))) +
#   geom_sf()
# --- fit log glm model to determine the fit up to 50% capacity ----------
.logmodel <- glm(terr_count ~ years_since, family=poisson(link='log'), data=terr_counts)
# --- visualise initial model ------
tibble(years_since  = seq(0,50, by=0.01)) %>%
broom::augment(.logmodel, newdata=., se_fit=T, type.predict = "response") %>%
ggplot(., aes(x=years_since, y = .fitted))+
geom_point(data=terr_counts, aes(x=years_since, y=terr_count), inherit.aes = F, alpha=0.6)+
geom_line() +
geom_ribbon(aes(ymin=.fitted -(1.96*.se.fit),ymax=.fitted +(1.96*.se.fit) ), alpha=0.3)+
coord_cartesian(ylim=c(0,upper_capacity +10))+
theme_bw()
source(file.path(here::here(),"R_Otter_workflow/3_Pop_expansion_predictions", 'logistic_growth.R'))
# generate logistic models...
hacked_df <-  seq(lower_capacity, upper_capacity, by=1) %>%
purrr::map(., ~logistic_growth(., .logmodel)) %>%
bind_rows()
# function to create capcity ribbon for plot.
ribbon_df <- function() tibble(year_adj = seq(2000,2070, by=70),.fitted = seq(0,200, by=200))
mid_cap <- function() lower_capacity + ((upper_capacity-lower_capacity)*0.5)
# create plot.
hacked_df %>%
# filter(cap_name==115)%>%
ggplot(., aes(x=year_adj, y=.fitted))+
### This bit adds the ribbon to show estimated maximum  terr. capacity.
# geom_ribbon(data=ribbon_df(), aes(ymin=lower_capacity, ymax=upper_capacity, xmin=2000),
#             fill='grey90', size=0.1, alpha=0.2, linetype=2, color="grey10") +
# annotate("text", x=2020, y = mid_cap(),
#          label = "predicted territory capacity range", size=3) +
# geom_segment(aes(x = 2020, y = mid_cap() + 5, xend = 2020, yend = upper_capacity -1),
#              arrow = arrow(length = unit(0.01, "npc")),lwd=0.5, color="grey20") +
# geom_segment(aes(x = 2020, y = mid_cap() - 5, xend = 2020, yend = lower_capacity +1),
# arrow = arrow(length = unit(0.01, "npc")), lwd=0.5, color="grey20") +
### This gives just the lines
# geom_line(aes(group=reorder(cap_name, rev(cap_name)), color=cap_name), lwd=0.5, alpha=0.9)+
# stat_summary(fun = mean, geom = 'line', size=0.6, alpha=0.6, linetype=1, color="grey20") +
# # stat_summary(fun = min, geom = 'line', size=0.4, alpha=0.6, linetype=2, color="grey20") +
# # stat_summary(fun = max, geom = 'line', size=0.4, alpha=0.6, linetype=2, color="grey20") +
# # scale_colour_viridis_c(option='turbo')+
# scale_colour_continuous_sequential("Batlow", rev=F) +
# guides(colour = guide_colourbar(barwidth = 8, barheight = 0.5, title="Territory Capacity", title.vjust=1)) +
## this generates the Confidence interval version (CIs are very debatable - safer to levave?)
geom_ribbon(aes(ymin=pred.lwr, ymax = pred.upr,
group=reorder(cap_name, rev(cap_name))),
fill='#18BFC2', alpha=0.04) +
# geom_ribbon(aes(ymin=pred.lwr, ymax = pred.upr, group=reorder(cap_name, rev(cap_name)), fill=cap_name), colour=NA) +
stat_summary(aes(y=pred.lwr), fun = min, geom = 'line', size=0.3, alpha=0.9, linetype=2, color="grey10") +
stat_summary(aes(y=pred.upr),fun = max, geom = 'line', size=0.3, alpha=0.9, linetype=2, color="grey10") +
# scale_fill_continuous_sequential("TealGrn", rev=F) +
# guides(fill = guide_colourbar(barwidth = 8, barheight = 0.5, title="Territory Capacity")) +
#adds mean model to plot
stat_summary(fun = mean, geom = 'line', size=0.6, alpha=0.9, linetype=1, color="grey10") +
# adds original data
geom_point(data=terr_counts, aes(x=year_adj, y=terr_count), shape=21, size=1.5,
stroke = 1.2)+
# define plot style n stuff
coord_cartesian(ylim=c(0,upper_capacity +5), xlim = c(2007, 2045))+
labs(x = 'Year', y="Number of Territories")+
theme_bw() +
theme(legend.position = "bottom",
axis.title.y = element_text(margin = margin(t = 0, r = 3, b = 0, l = 0)),
axis.title.x = element_text(margin = margin(t = 3, r = 0, b = 0, l = 0))) #+
get_summ <- function(df, .fun1, .fun2, col_name, out_names){
df %>%
filter(cap_name == .fun1(hacked_df$cap_name),
{{col_name}} >= lower_capacity,
{{col_name}} <=upper_capacity) %>%
summarise(!!out_names := .fun2(year_adj))
}
bind_cols(
get_summ(hacked_df, max, min, .fitted, 'early_mean'),
get_summ(hacked_df, min, max, .fitted, 'late_mean'),
get_summ(hacked_df, max, min, pred.upr, 'lower_CI'),
get_summ(hacked_df, min, max, pred.lwr, 'upper_CI')
)
library(beavertools)
library(tidyverse)
library(sf)
library(broom)
library(patchwork)
#-------------define folder root -------------
export_dir <- file.path(here::here(),"R_Otter_workflow/2_Territory_simulations/exports")
plot_dir <- file.path(here::here(),"R_Otter_workflow/2_Territory_simulations/plots")
# ----- generate extent and titles for mapping ------
target_ext <- inflate_bbox(RivOtter_Catch_Area, 10)
# ------------ Read Data ------------------
Real_terrs <- readRDS('R_Otter_workflow/1_Feed_Sign_Mapping/exports/reclass_terr_list.Rds')
# MasterMap River Network not released with the package due to licensing issues.
MMRN_BeavNetOtter <- sf::read_sf('run/data/BeaverNetwork_Otter.gpkg') # MasterMap Data
# OS Open Rivers Network - included with the package
# ORN_BeavNetOtter <- RivOtter_BeaverNet
#------- Observed territory Habitat stats ----------
# need to calculate some stats here and find out what kind of BFI values we're currently seeing on the Otter.
terr_list <- readRDS(file=file.path(here::here(),'R_Otter_workflow/1_Feed_Sign_Mapping/exports/reclass_terr_list2.Rds'))
survey_years <- unique(RivOtter_FeedSigns$SurveySeason)
source(file.path(here::here(), 'R_Otter_workflow/2_Territory_simulations/terr_BFI_df.R'))
Terr_df <- terr_BFI_df(terr_list, MMRN_BeavNetOtter, survey_years)
lower_BFI <- round(min(Terr_df$mean_BFI_40m),1)
upper_BFI <- round(mean(Terr_df$mean_BFI_40m), 1)
message(sprintf("Lower BFI threshold: %s \nUpper BFI threshold: %s",lower_BFI, upper_BFI))
# ---------- run terriroty generation for all reaches for each network
run_terr_gen <- function(riv_network, overwrite=FALSE, save_out=TRUE){
fileName <- file.path(export_dir, paste('PT_', deparse(substitute(riv_network)),'.Rds', sep=""))
# print(fileName)
if (file.exists(fileName) && isFALSE(overwrite)){
message(sprintf("Potential territrories created in: %s", fileName))
message("Loading previously generated file...")
terr_out <- readRDS(fileName)
} else{
t1 <- Sys.time()
terr_out <-  gen_territories(riv_network, multicore = T, progbar = T)
if (isTRUE(save_out)){
saveRDS(terr_out, file=fileName)
}
message(sprintf('Potential Territory Generation Run Time = %s minutes', round(Sys.time()-t1,1)))
}
return(terr_out)
}
RivOtter_Terrs <- run_terr_gen(MMRN_BeavNetOtter)
(nrow(MMRN_BeavNetOtter) - nrow(RivOtter_Terrs))/nrow(MMRN_BeavNetOtter)*100
# terrs_union <- sf::st_union(MMRN_BeavNetOtter) %>%
#   st_as_sf()
#plot to check that whole network is cvered by the theoretical territories.
# ggplot()+
#   geom_sf(MMRN_BeavNetOtter, mapping= aes(), colour='red')+
#   geom_sf(terrs_union, mapping= aes(), colour='blue') +
#
#   theme_bw()
# ggplot(RivOtter_Terrs, aes(x=Terr_Leng))+
#   geom_density()
# ------------- Run territory cap -------------
run_terr_cap <- function(pot_terrs, veg, overwrite=FALSE, save_out=TRUE){
fileName <- file.path(export_dir, paste('TC_', deparse(substitute(pot_terrs)),'.Rds', sep=""))
# print(fileName)
if (file.exists(fileName) && isFALSE(overwrite)){
message(sprintf("Territory capacity created in: %s", fileName))
message("Loading previously generated file...")
cap_out <- readRDS(fileName)
} else {
t1 <- Sys.time()
cap_out <-territory_cap(pot_terrs, min_veg = veg , multicore = TRUE)
if (isTRUE(save_out)){
saveRDS(cap_out, file=fileName)
}
message(sprintf('Territory Capacity Run Time = %s minutes', round(Sys.time()-t1,1)))
}
return(cap_out)
}
RivOtter_Terrs_upper <- RivOtter_Terrs
terr_cap_lowBFI <- run_terr_cap(RivOtter_Terrs, lower_BFI, overwrite=F)
terr_cap_uppBFI <- run_terr_cap(RivOtter_Terrs_upper, upper_BFI, overwrite=F)
Terr_Cap_df <- terr_cap_lowBFI %>%
mutate(sim=as.character(lower_BFI)) %>%
bind_rows(., terr_cap_uppBFI %>%
mutate(sim=as.character(upper_BFI)))
# plot showing the territory length distributions for each of these example simulations.
ggplot(Terr_Cap_df, aes(x=Terr_Leng, fill=sim, after_stat(count))) +
geom_density(alpha=0.5) +
labs(x='territory length (m)', fill='minimum BFI threshold') +
scale_fill_brewer(palette = "Dark2")+
theme_bw() +
theme(legend.position = "bottom") +
ggsave(filename = file.path(plot_dir, 'TerritoryLengthDist.png'), dpi=600, height=180, width=180, units='mm')
# summary stats for territory length if needed
Terr_sum_df <- Terr_Cap_df %>%
sf::st_drop_geometry()%>%
group_by(sim) %>%
summarise(mean_length = mean(Terr_Leng),
stdev_Length = sd(Terr_Leng),
n_terrs = n())
# ---------- Plot Territory Capacities for both Networks ---------
capacity_plot <- function(cap_lowBFI, cap_uppBFI){
p1 <- plot_capacity(cap_uppBFI, buffer=50, basemap = F, catchment = RivOtter_Catch_Area,
river_net = MMRN_BeavNetOtter, plot_extent = target_ext, north_arrow = F,
scalebar = F, axes_units = F, add_hillshade =F)+
annotate("text", x = 304000, y = 81600, size = 2.4,
label = sprintf('n territories = %s',
Terr_sum_df$n_terrs[Terr_sum_df$sim == as.character(upper_BFI)]))+
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank())
p2 <- plot_capacity(cap_lowBFI, buffer=50, basemap = F, catchment = RivOtter_Catch_Area,
river_net = MMRN_BeavNetOtter, plot_extent = target_ext,
axes_units = F, add_hillshade =F)+
annotate("text", x = 304000, y = 81600, size = 2.4,
label = sprintf('n territories = %s',
Terr_sum_df$n_terrs[Terr_sum_df$sim == as.character(lower_BFI)]))+
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank())
p3 <- p1 + p2 + plot_annotation(
caption = 'Contains: OS data © Crown copyright and database right 2021', #© OpenStreetMap contributors,
theme = theme(plot.caption = element_text(size = 6)))
return(p3)
}
TerrCapPlot <- capacity_plot(terr_cap_lowBFI, terr_cap_uppBFI)
ggsave(filename = file.path(plot_dir, 'Lower_Upper_Capacity_maps.png'), plot=TerrCapPlot,
dpi=300, height=138, width=180, units='mm')
# ------- Run Territory simulation based on the desired upper and lower  minimum BFI requirements. -----------
run_terr_simulation <- function(fileName, overwrite=FALSE){
if (file.exists(fileName) && isFALSE(overwrite)){
message(sprintf("Simulation results already generated. See: %s", fileName))
message("Loading previously generated file...")
sim_terr <- readRDS(fileName)
} else {
t1 <- Sys.time()
sim_terr <- sim_terr_cap(MMRN_BeavNetOtter, n_p_terr_sim=100, n_hab_sim=2, min_veg = c(lower_BFI, upper_BFI))
saveRDS(sim_terr, fileName)
Sys.time()-t1
return(sim_terr)
}
}
sim_terr <- run_terr_simulation(file.path(export_dir, 'sim_terr.Rds'), overwrite=F)
# plot simulation results... load again if needed.
sim_terr %>%
mutate(min_BFI_c = as.character(min_BFI)) %>%
ggplot(., aes(x=min_BFI_c, y=n, fill=min_BFI_c)) +
geom_point(shape = 21, alpha = 0.7,position = position_jitterdodge(
jitter.width = 0.1), stroke = 0.5,show.legend = F) +
geom_boxplot(show.legend = F, alpha=0.5, width=0.3, outlier.shape =NA) +
scale_fill_brewer(palette = "Dark2", ) +
coord_cartesian(y=c(100,200))+
labs(y= "n territories", x = 'Beaver Forage Index (BFI) Value') +
theme_bw() +
ggsave(filename = file.path(plot_dir, 'SimulationResults1.png'), dpi=600, height=180, width=180, units='mm')
# plot simulation results... load again if needed.
sim_terr %>%
mutate(min_BFI_c = as.character(min_BFI)) %>%
ggplot(., aes(x=min_BFI_c, y=n, fill=min_BFI_c)) +
geom_point(shape = 21, alpha = 0.7,position = position_jitterdodge(
jitter.width = 0.1), stroke = 0.5,show.legend = F) +
geom_boxplot(show.legend = F, alpha=0.5, width=0.3, outlier.shape =NA) +
scale_fill_brewer(palette = "Dark2", ) +
coord_cartesian(y=c(100,200))+
labs(y= "n territories", x = 'Beaver Forage Index (BFI) Value') +
theme_bw() %>%
ggsave(., filename = file.path(plot_dir, 'SimulationResults1.png'), dpi=600, height=180, width=180, units='mm')
# plot simulation results... load again if needed.
st <- sim_terr %>%
mutate(min_BFI_c = as.character(min_BFI)) %>%
ggplot(., aes(x=min_BFI_c, y=n, fill=min_BFI_c)) +
geom_point(shape = 21, alpha = 0.7,position = position_jitterdodge(
jitter.width = 0.1), stroke = 0.5,show.legend = F) +
geom_boxplot(show.legend = F, alpha=0.5, width=0.3, outlier.shape =NA) +
scale_fill_brewer(palette = "Dark2", ) +
coord_cartesian(y=c(100,200))+
labs(y= "n territories", x = 'Beaver Forage Index (BFI) Value') +
theme_bw()
st
ggsave(st, filename = file.path(plot_dir, 'SimulationResults1.png'), dpi=600, height=180, width=180, units='mm')
sim_terr
?sd
sim_terr %>%
group_by(minBFI) %>%
summarise(mean=mean, stdev=sd)
sim_terr %>%
group_by(min_BFI) %>%
summarise(mean=mean, stdev=sd)
sim_terr %>%
group_by(min_BFI) %>%
summarise(.mean=mean, .stdev=sd)
sim_terr %>%
group_by(min_BFI) %>%
summarise(.mean=mean(n), .stdev=sd(n))
sim_terr %>%
sf::st_drop_geometry() %>%
group_by(min_BFI) %>%
summarise(.mean=mean(n), .stdev=sd(n))
sim_terr %>%
sf::st_drop_geometry() %>%
group_by(min_BFI) %>%
summarise(.mean=mean(n), .stdev=sd(n),
.min=min(n), .max=max(n))
