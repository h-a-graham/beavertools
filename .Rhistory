RivOtter_Terrs
nrow(MMRN_BeavNetOtter)
nrow(MMRN_BeavNetOtter) - nrow(RivOtter_Terrs)
(nrow(MMRN_BeavNetOtter) - nrow(RivOtter_Terrs))/nrow(MMRN_BeavNetOtter)*100
terrs_union <- sf::st_union(MMRN_BeavNetOtter)
terrs_union
terrs_union <- sf::st_union(MMRN_BeavNetOtter) %>%
st_as_as()
terrs_union <- sf::st_union(MMRN_BeavNetOtter) %>%
st_as_sf()
ggplot(terrs_union)%>%
plot_sf()
ggplot(terrs_union)%>%
geom_sf()
ggplot(terrs_union)+
geom_sf()
ggplot()+
geom_sf(terrs_union) +
# ggplot(RivOtter_Terrs, aes(x=Terr_Leng))+
#   geom_density()
# ------------- Run territory cap -------------
run_terr_cap <- function(pot_terrs, veg, overwrite=FALSE, save_out=TRUE){
fileName <- file.path(export_dir, paste('TC_', deparse(substitute(pot_terrs)),'.Rds', sep=""))
# print(fileName)
if (file.exists(fileName) && isFALSE(overwrite)){
message(sprintf("Territory capacity created in: %s", fileName))
message("Loading previously generated file...")
cap_out <- readRDS(fileName)
} else {
t1 <- Sys.time()
cap_out <-territory_cap(pot_terrs, min_veg = veg , multicore = TRUE)
if (isTRUE(save_out)){
saveRDS(cap_out, file=fileName)
}
message(sprintf('Territory Capacity Run Time = %s minutes', round(Sys.time()-t1,1)))
}
return(cap_out)
}
ggplot()+
geom_sf(terrs_union)
ggplot(MMRN_BeavNetOtter)+
geom_sf()
terrs_union
ggplot()+
geom_sf(terrs_union, aes(colour=x)) +
gem_sf(MMRN_BeavNetOtter)
MMRN_BeavNetOtter
ggplot()+
geom_sf(terrs_union, aes(fill=x)) +
gem_sf(MMRN_BeavNetOtter)
ggplot()+
geom_sf(terrs_union, aes(fill=x)) +
gem_sf(MMRN_BeavNetOtter, aes(colour=Str_order))
ggplot()+
geom_sf(terrs_union, mapping= aes(fill=x)) +
geom_sf(MMRN_BeavNetOtter, aes(colour=Str_order))
ggplot()+
geom_sf(terrs_union, mapping= aes(fill=x)) +
geom_sf(MMRN_BeavNetOtter, mapping= aes(colour=Str_order))
ggplot()+
geom_sf(terrs_union, mapping= aes()) +
geom_sf(MMRN_BeavNetOtter, mapping= aes())
ggplot()+
geom_sf(terrs_union, mapping= aes(), colour='blue') +
geom_sf(MMRN_BeavNetOtter, mapping= aes(), colour='pink')+
theme_bw()
ggplot()+
geom_sf(MMRN_BeavNetOtter, mapping= aes(), colour='red')+
geom_sf(terrs_union, mapping= aes(), colour='blue') +
theme_bw()
nrow(RivOtter_Terrs)
lower_BFI
upper_BFI
raster::polygonise
?polgonise
sum(MMRN_BeavNetOtter$Length_m)
sum(MMRN_BeavNetOtter$Length_m)/1000
sum(MMRN_BeavNetOtter$Length)/1000
sum(st_length(MMRN_BeavNetOtter$Length))/1000
sum(st_length(MMRN_BeavNetOtter))/1000
library(beavertools)
library(tidyverse)
library(sf)
library(broom)
library(patchwork)
#-------------define folder root -------------
export_dir <- file.path(here::here(),"R_Otter_workflow/2_Territory_simulations/exports")
plot_dir <- file.path(here::here(),"R_Otter_workflow/2_Territory_simulations/plots")
# ----- generate extent and titles for mapping ------
target_ext <- inflate_bbox(RivOtter_Catch_Area, 10)
# ------------ Read Data ------------------
Real_terrs <- readRDS('R_Otter_workflow/1_Feed_Sign_Mapping/exports/reclass_terr_list.Rds')
# MasterMap River Network not released with the package due to licensing issues.
MMRN_BeavNetOtter <- sf::read_sf('run/data/BeaverNetwork_Otter.gpkg') # MasterMap Data
# OS Open Rivers Network - included with the package
# ORN_BeavNetOtter <- RivOtter_BeaverNet
#------- Observed territory Habitat stats ----------
# need to calculate some stats here and find out what kind of BFI values we're currently seeing on the Otter.
terr_list <- readRDS(file=file.path(here::here(),'R_Otter_workflow/1_Feed_Sign_Mapping/exports/reclass_terr_list2.Rds'))
survey_years <- unique(RivOtter_FeedSigns$SurveySeason)
source(file.path(here::here(), 'R_Otter_workflow/2_Territory_simulations/terr_BFI_df.R'))
Terr_df <- terr_BFI_df(terr_list, MMRN_BeavNetOtter, survey_years)
lower_BFI <- round(min(Terr_df$mean_BFI_40m),1)
upper_BFI <- round(mean(Terr_df$mean_BFI_40m), 1)
message(sprintf("Lower BFI threshold: %s \nUpper BFI threshold: %s",lower_BFI, upper_BFI))
# ---------- run terriroty generation for all reaches for each network
run_terr_gen <- function(riv_network, overwrite=FALSE, save_out=TRUE){
fileName <- file.path(export_dir, paste('PT_', deparse(substitute(riv_network)),'.Rds', sep=""))
# print(fileName)
if (file.exists(fileName) && isFALSE(overwrite)){
message(sprintf("Potential territrories created in: %s", fileName))
message("Loading previously generated file...")
terr_out <- readRDS(fileName)
} else{
t1 <- Sys.time()
terr_out <-  gen_territories(riv_network, multicore = T, progbar = T)
if (isTRUE(save_out)){
saveRDS(terr_out, file=fileName)
}
message(sprintf('Potential Territory Generation Run Time = %s minutes', round(Sys.time()-t1,1)))
}
return(terr_out)
}
RivOtter_Terrs <- run_terr_gen(MMRN_BeavNetOtter)
(nrow(MMRN_BeavNetOtter) - nrow(RivOtter_Terrs))/nrow(MMRN_BeavNetOtter)*100
# ------------- Run territory cap -------------
run_terr_cap <- function(pot_terrs, veg, overwrite=FALSE, save_out=TRUE){
fileName <- file.path(export_dir, paste('TC_', deparse(substitute(pot_terrs)),'.Rds', sep=""))
# print(fileName)
if (file.exists(fileName) && isFALSE(overwrite)){
message(sprintf("Territory capacity created in: %s", fileName))
message("Loading previously generated file...")
cap_out <- readRDS(fileName)
} else {
t1 <- Sys.time()
cap_out <-territory_cap(pot_terrs, min_veg = veg , multicore = TRUE)
if (isTRUE(save_out)){
saveRDS(cap_out, file=fileName)
}
message(sprintf('Territory Capacity Run Time = %s minutes', round(Sys.time()-t1,1)))
}
return(cap_out)
}
RivOtter_Terrs_upper <- RivOtter_Terrs
terr_cap_lowBFI <- run_terr_cap(RivOtter_Terrs, lower_BFI, overwrite=F)
terr_cap_uppBFI <- run_terr_cap(RivOtter_Terrs_upper, upper_BFI, overwrite=F)
Terr_Cap_df <- terr_cap_lowBFI %>%
mutate(sim=as.character(lower_BFI)) %>%
bind_rows(., terr_cap_uppBFI %>%
mutate(sim=as.character(upper_BFI)))
# plot showing the territory length distributions for each of these example simulations.
ggplot(Terr_Cap_df, aes(x=Terr_Leng, fill=sim, after_stat(count))) +
geom_density(alpha=0.5) +
labs(x='territory length (m)', fill='minimum BFI threshold') +
scale_fill_brewer(palette = "Dark2")+
theme_bw() +
theme(legend.position = "bottom") +
ggsave(filename = file.path(plot_dir, 'TerritoryLengthDist.png'), dpi=600, height=180, width=180, units='mm')
# summary stats for territory length if needed
Terr_sum_df <- Terr_Cap_df %>%
sf::st_drop_geometry()%>%
group_by(sim) %>%
summarise(mean_length = mean(Terr_Leng),
stdev_Length = sd(Terr_Leng),
n_terrs = n())
Terr_sum_df
run_terr_simulation <- function(fileName, overwrite=FALSE){
if (file.exists(fileName) && isFALSE(overwrite)){
message(sprintf("Simulation results already generated. See: %s", fileName))
message("Loading previously generated file...")
sim_terr <- readRDS(fileName)
} else {
t1 <- Sys.time()
sim_terr <- sim_terr_cap(MMRN_BeavNetOtter, n_p_terr_sim=100, n_hab_sim=2, min_veg = c(lower_BFI, upper_BFI))
saveRDS(sim_terr, fileName)
Sys.time()-t1
return(sim_terr)
}
}
sim_terr <- run_terr_simulation(file.path(export_dir, 'sim_terr.Rds'), overwrite=F)
# plot simulation results... load again if needed.
sim_terr %>%
mutate(min_BFI_c = as.character(min_BFI)) %>%
ggplot(., aes(x=min_BFI_c, y=n, fill=min_BFI_c)) +
geom_point(shape = 21, alpha = 0.7,position = position_jitterdodge(
jitter.width = 0.1), stroke = 0.5,show.legend = F) +
geom_boxplot(show.legend = F, alpha=0.5, width=0.3, outlier.shape =NA) +
scale_fill_brewer(palette = "Dark2", ) +
coord_cartesian(y=c(100,200))+
labs(y= "n territories", x = 'Beaver Forage Index (BFI) Value') +
theme_bw() +
ggsave(filename = file.path(plot_dir, 'SimulationResults1.png'), dpi=600, height=180, width=180, units='mm')
# quick summary to retrieve the highest and lowest possible capacity values.
sim_terr %>%
sf::st_drop_geometry() %>%
summarise(lowest = min(n),
highest = max(n))
# devtools::load_all()
library(beavertools)
library(patchwork)
library(sf)
library(magrittr)
library(tidyverse)
library(patchwork)
library(ggfortify)
library(investr)
library(colorspace)
library(grid)
library(gtable)
# devtools::load_all()
library(beavertools)
plot_dir <- file.path(here::here(),"R_Otter_workflow/3_Pop_expansion_predictions/plots")
sim_dir <- file.path(here::here(),"R_Otter_workflow/2_Territory_simulations/exports")
# ---- Read in Data Territroy count data --------------
reclass_terr_list <- readRDS(file='R_Otter_workflow/1_Feed_Sign_Mapping/exports/reclass_terr_list2.Rds')
# get unique names for survey years...
plot_names <- unique(RivOtter_FeedSigns$SurveySeason)
# What is the capacity of the catchment? WILL NEED UPDATING WITH RANGES ETC WHEN SIMULATIONS ARE DONE.
cap_limits <- read_rds(file.path(sim_dir, 'sim_terr.Rds')) %>%
sf::st_drop_geometry() %>%
summarise(lowest = min(n),
highest = max(n))
lower_capacity <- cap_limits$lowest
upper_capacity <- cap_limits$highest
cap_limits
#  ------- set up dataframe for observed territory counts... -------
date_list <- lubridate::dmy(c("30-12-2014", "30-12-2015", "30-12-2016",
"30-12-2017", "30-12-2018", "30-12-2019",
"30-12-2020"))
years_since_release <- c(8:14)
get_terr_counts <- function(terr_map, .season, .year, .ysr){
terr_map %>%
dplyr::filter(user_class == 'Territory') %>%
summarise(terr_count = n(), season= .season, year = .year, years_since = .ysr)
}
count_obj_list <- list(reclass_terr_list, plot_names, date_list, years_since_release)
terr_counts <-  purrr::pmap(count_obj_list, ~get_terr_counts(..1, ..2, ..3, ..4)) %>%
bind_rows() %>%
mutate(year_adj = years_since + 2007) %>%
mutate(terr_count = ifelse(season %in% c('2018 - 2019', '2019 - 2020'), terr_count+1,
ifelse(season %in% c('2020 - 2021'),terr_count + 2, terr_count))) %>% # required because some territories not correctly identified due to semi-automate process.
mutate(name = 'Observed Data')
.logmodel <- glm(terr_count ~ years_since, family=poisson(link='log'), data=terr_counts)
# --- visualise initial model ------
tibble(years_since  = seq(0,50, by=0.01)) %>%
broom::augment(.logmodel, newdata=., se_fit=T, type.predict = "response") %>%
ggplot(., aes(x=years_since, y = .fitted))+
geom_point(data=terr_counts, aes(x=years_since, y=terr_count), inherit.aes = F, alpha=0.6)+
geom_line() +
geom_ribbon(aes(ymin=.fitted -(1.96*.se.fit),ymax=.fitted +(1.96*.se.fit) ), alpha=0.3)+
coord_cartesian(ylim=c(0,upper_capacity +10))+
theme_bw()
source(file.path(here::here(),"R_Otter_workflow/3_Pop_expansion_predictions", 'logistic_growth.R'))
# generate logistic models...
hacked_df <-  seq(lower_capacity, upper_capacity, by=1) %>%
purrr::map(., ~logistic_growth(., .logmodel)) %>%
bind_rows()
# function to create capcity ribbon for plot.
ribbon_df <- function() tibble(year_adj = seq(2000,2070, by=70),.fitted = seq(0,200, by=200))
mid_cap <- function() lower_capacity + ((upper_capacity-lower_capacity)*0.5)
# create plot.
hacked_df %>%
# filter(cap_name==115)%>%
ggplot(., aes(x=year_adj, y=.fitted))+
### This bit adds the ribbon to show estimated maximum  terr. capacity.
# geom_ribbon(data=ribbon_df(), aes(ymin=lower_capacity, ymax=upper_capacity, xmin=2000),
#             fill='grey90', size=0.1, alpha=0.2, linetype=2, color="grey10") +
# annotate("text", x=2020, y = mid_cap(),
#          label = "predicted territory capacity range", size=3) +
# geom_segment(aes(x = 2020, y = mid_cap() + 5, xend = 2020, yend = upper_capacity -1),
#              arrow = arrow(length = unit(0.01, "npc")),lwd=0.5, color="grey20") +
# geom_segment(aes(x = 2020, y = mid_cap() - 5, xend = 2020, yend = lower_capacity +1),
# arrow = arrow(length = unit(0.01, "npc")), lwd=0.5, color="grey20") +
### This gives just the lines
geom_line(aes(group=reorder(cap_name, rev(cap_name)), color=cap_name), lwd=0.5, alpha=0.9)+
stat_summary(fun = mean, geom = 'line', size=0.6, alpha=0.6, linetype=1, color="grey20") +
# stat_summary(fun = min, geom = 'line', size=0.4, alpha=0.6, linetype=2, color="grey20") +
# stat_summary(fun = max, geom = 'line', size=0.4, alpha=0.6, linetype=2, color="grey20") +
# scale_colour_viridis_c(option='turbo')+
scale_colour_continuous_sequential("Batlow", rev=F) +
guides(colour = guide_colourbar(barwidth = 8, barheight = 0.5, title="Territory Capacity", title.vjust=1)) +
## this generates the Confidence interval version (CIs are very debatable - safer to levave?)
# geom_ribbon(aes(ymin=pred.lwr, ymax = pred.upr, group=reorder(cap_name, rev(cap_name)), fill=cap_name), colour=NA) +
# stat_summary(aes(y=pred.lwr), fun = min, geom = 'line', size=0.3, alpha=0.6, linetype=1, color="grey20") +
# stat_summary(aes(y=pred.upr),fun = max, geom = 'line', size=0.3, alpha=0.6, linetype=1, color="grey20") +
# scale_fill_continuous_sequential("TealGrn", rev=F) +
# guides(fill = guide_colourbar(barwidth = 8, barheight = 0.5, title="Territory Capacity")) +
#adds mean model to plot
stat_summary(fun = mean, geom = 'line', size=0.6, alpha=0.6, linetype=1, color="grey20") +
# adds original data
geom_point(data=terr_counts, aes(x=year_adj, y=terr_count), shape=21, size=2)+
# define plot style n stuff
coord_cartesian(ylim=c(0,upper_capacity +5), xlim = c(2007, 2040))+
labs(x = 'Year', y="Number of Territories")+
theme_bw() +
theme(legend.position = "bottom",
axis.title.y = element_text(margin = margin(t = 0, r = 3, b = 0, l = 0)),
axis.title.x = element_text(margin = margin(t = 3, r = 0, b = 0, l = 0))) +
ggsave(file.path(plot_dir, 'TerritoryPredictiond.png'),
dpi=600, height=180, width=180, units='mm')
long_df <- hacked_df %>%
pivot_longer(., cols=c(growth_rate, n_terr_growth, hartman_rate), names_to = "mid", values_to = 'mid.long')%>%
mutate(mid = ifelse(mid=='growth_rate', "Expansion Rate",
ifelse(mid=="n_terr_growth","New Territories per Year", "Expansion Rate / time")),
density = .fitted/(as.numeric(sf::st_area(RivOtter_Catch_Area))/1e+6))
# function to generate the desired pop dynamics plots.
pop.dynams <- function(df, x_val, x_lab, leg_pos){
ggplot(df, aes(x=!! dplyr::sym(x_val) , y=mid.long , colour=cap_name))+
# geom_ribbon(aes(ymin=lwr.long, ymax = upr.long, group=reorder(cap_name, rev(cap_name)), fill=cap_name), lwd=0.9) +
geom_line(aes(group=c(reorder(cap_name, rev(cap_name)))), lwd=0.5, alpha=0.7) +
# scale_colour_viridis_c(option='turbo')+
scale_colour_continuous_sequential("Batlow", rev=F) +
guides(colour = guide_colourbar(barwidth = 8, barheight = 0.5, title="Territory Capacity", title.vjust=1)) +
labs(x = x_lab, y='')+
theme_bw() +
theme(legend.position = leg_pos,
axis.title.x = element_text(margin = margin(t = 10, r = 0, b = 6, l = 0))) +
facet_wrap(~mid, scales = "free")
}
# create stacked plot.
long_df %>%
pop.dynams(., 'years_since', "Years since establishment", "none")/
long_df %>%
pop.dynams(., 'density', expression(paste("Density ", (territories/km) ^2)), "bottom") +
theme(strip.background = element_blank(), strip.text = element_blank()) +
ggsave(file.path(plot_dir, 'TerritoryDynamics.png'),
dpi=600, height=180, width=180, units='mm')
# ------ management impacts ----------------
# This function fits the new management scenarios based on the time of management start and
# how many territories are removed each year.
source(file.path(here::here(), 'R_Otter_workflow/3_Pop_expansion_predictions/add_general_facet_labs.R'))
mgmt_scenario <- function(df, .mgmt_start, .mgmt_n_terrs) {
gen_mgmt_curve <- function(mgmt_start, mgmt_n_terrs){
growth_vec <- vector("double", length(nrow(df)))
for (i in seq_len(nrow(df))) {
if (df$year_adj[i] < mgmt_start){
g <- round(df$.fitted[i],2)
} else{
g_rate <- df$n_terr_growth[which.min(abs(df$.fitted - g))]
g <- g + g_rate - mgmt_n_terrs
}
growth_vec[i] <- g
}
return(tibble(mgmt_growth = growth_vec,
mgmt_year = mgmt_start,
mgmt_removed = mgmt_n_terrs) %>%
bind_cols(df))
}
dist_func <- function(.year, .nList){
purrr::map(.nList, ~gen_mgmt_curve(.year, .)) %>%
bind_rows()
}
purrr::map(.mgmt_start, ~dist_func(., .mgmt_n_terrs)) %>%
bind_rows() #%>%
# mutate_if(is.numeric, ~replace(., .<0, NA))
}
mgmt_df <- hacked_df %>%
group_by(cap_name) %>%
group_split() %>%
purrr::map(., ~ mgmt_scenario(., c(2022, 2025, 2035), c(5, 7, 10, 15))) %>%
bind_rows()
# create plot.
p <- mgmt_df %>%
# filter(cap_name==115)%>%
ggplot(., aes(x=year_adj, y=.fitted))+
# shows range of unmanaged scenario
stat_summary(fun = min, geom = 'line', size=0.4, alpha=0.6, linetype=2, color="grey20") +
stat_summary(fun = max, geom = 'line', size=0.4, alpha=0.6, linetype=2, color="grey20") +
### This gives just the lines
geom_line(aes(y=mgmt_growth, group=reorder(cap_name, rev(cap_name)), color=cap_name), lwd=0.5, alpha=0.5)+
# scale_colour_viridis_c(option='turbo') +
scale_colour_continuous_sequential("Batlow", rev=F) +
guides(colour = guide_colourbar(barwidth = 8, barheight = 0.5, title="Territory Capacity", title.vjust=1)) +
facet_grid(mgmt_removed ~ mgmt_year ) +
# define plot style n stuff
coord_cartesian(ylim=c(8,upper_capacity +5), xlim = c(2007, 2060))+
labs(x = 'Year', y="Number of Territories")+
theme_bw() +
theme(legend.position = "bottom",
axis.title.y = element_text(margin = margin(t = 0, r = 3, b = 0, l = 0)),
axis.title.x = element_text(margin = margin(t = 3, r = 0, b = 0, l = 0)))
add_general_facet_labs(p, 'n territories removed each year', ' Year managment starts') %>%
ggsave(file.path(plot_dir, 'MgmtDynamics.png'), .,
dpi=600, height=180, width=180, units='mm')
hacked_df
?arrange
?top_n
hacked_df %>%
group_by(cap_name)%>%
arrange(.fitted, .by_group = T) %>%
top_n(1)
hacked_df %>%
group_by(cap_name)%>%
top_n(1, wt=desc(.fitted))
hacked_df %>%
group_by(cap_name)%>%
top_n(1, wt=asc(.fitted))
?desc
hacked_df %>%
group_by(cap_name)%>%
top_n(1, wt=arrange(.fitted))
hacked_df %>%
group_by(cap_name)%>%
top_n(1, wt=arrange(.fitted))
hacked_df %>%
group_by(cap_name)%>%
top_n(1, wt=desc(.fitted))
hacked_df %>%
group_by(cap_name)%>%
top_n(1, wt=.fitted)
hacked_df %>%
group_by(cap_name)%>%
unique(.fitted)%>%
top_n(1, wt=.fitted)
hacked_df %>%
group_by(cap_name)%>%
unique(., .fitted)%>%
top_n(1, wt=.fitted)
hacked_df %>%
group_by(cap_name)%>%
distinct(.fitted)%>%
top_n(1, wt=.fitted)
?distinct
hacked_df %>%
group_by(cap_name)%>%
distinct(.fitted, .keep_all=TRUE)%>%
top_n(1, wt=.fitted)
hacked_df %>%
group_by(cap_name)%>%
distinct(.fitted, .keep_all=TRUE)
hacked_df
hacked_df %>%
group_by(cap_name)%>%
distinct(.fitted)%>%
top_n(1, wt=dec(.fitted))
hacked_df %>%
group_by(cap_name)%>%
distinct(.fitted)
hacked_df %>%
group_by(cap_name)
hacked_df %>%
group_by(cap_name)%>%
distinct(round(.fitted,2))
hacked_df %>%
mutate(round_fit = round(.fitted,2)) %>%
group_by(cap_name)%>%
distinct(round_fit, .keep_all=TRUE)%>%
top_n(1, wt=dec(.fitted))
hacked_df %>%
mutate(round_fit = round(.fitted,2)) %>%
group_by(cap_name)%>%
distinct(round_fit, .keep_all=TRUE)
hacked_df %>%
mutate(round_fit = round(.fitted,2)) %>%
group_by(cap_name)%>%
distinct(round_fit, .keep_all=TRUE)%>%
top_n(1, wt=(.fitted))
hacked_df %>%
mutate(round_fit = round(.fitted,2)) %>%
group_by(cap_name)%>%
distinct(round_fit, .keep_all=TRUE)%>%
top_n(1, wt=(.fitted)) %>%
summarise(year_adj, min(), max())
hacked_df %>%
mutate(round_fit = round(.fitted,2)) %>%
group_by(cap_name)%>%
distinct(round_fit, .keep_all=TRUE)%>%
top_n(1, wt=(.fitted)) %>%
summarise(min = min(year_adj), max= max(year_adj))
hacked_df %>%
mutate(round_fit = round(.fitted,2)) %>%
group_by(cap_name)%>%
distinct(round_fit, .keep_all=TRUE)%>%
top_n(1, wt=(.fitted)) %>%
ungroup()%>%
summarise(min = min(year_adj), max= max(year_adj))
hacked_df %>%
mutate(round_fit = round(.fitted,2)) %>%
group_by(cap_name)%>%
distinct(round_fit, .keep_all=TRUE)%>%
top_n(1, wt=desc(.fitted)) %>%
ungroup()%>%
summarise(min = min(year_adj), max= max(year_adj))
rund(10.243)
round(10.243)
hacked_df %>%
mutate(round_fit = round(.fitted)) %>%
group_by(cap_name)%>%
distinct(round_fit, .keep_all=TRUE)%>%
top_n(1, wt=(.fitted)) %>%
ungroup()%>%
summarise(min = min(year_adj), max= max(year_adj))
citation('dplyr')
citation('purrr')
citation('ggspatial')
citation('ggplot2')
citation('parallel')
citation('foreach')
citation('magrittr')
citation('sf')
citation('progress')
citation('raster')
citation('spatialEco')
citation('doParallel')
citation('tcltk')
citation('lwgeom')
citation('magick')
citation('osmdata')
citation('gridExtra')
citation('ggpubr')
citation('exactextractr')
citation('parallel')
